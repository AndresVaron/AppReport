import 'dart:async';
import 'package:appreport/Temas/Temas.dart';
import 'package:flutter/gestures.dart';
import 'package:universal_html/prefer_universal/html.dart' as html;
import 'package:flutter/material.dart';
import 'dart:convert';

class Performance extends StatefulWidget {
  const Performance({Key key}) : super(key: key);
  @override
  PerformanceState createState() => PerformanceState();
}

class PerformanceState extends State<Performance> {
  final GlobalKey<ScaffoldState> _scaffoldKey = new GlobalKey<ScaffoldState>();
  InfoTema contador;
  int con;
  final String id = "performance";
  final int index = 8; //TODO
  bool estabaOff = false;

  @override
  Widget build(BuildContext context) {
    load();
    return Scaffold(
        key: _scaffoldKey,
        appBar: AppBar(
            title: Center(child: Text("Ups: " + con.toString())),
            actions: <Widget>[
              // action button
              IconButton(
                icon: Icon(Icons.refresh),
                onPressed: () {
                  refresh();
                },
              )
            ]),
        body: LayoutBuilder(builder: (context, constraints) {
          var largeScreen = constraints.maxWidth > 600 ? true : false;
//CambiarEsto para tamano min en celular
          double tamanhoTexto = 20;
          double sidePadding = constraints.maxWidth / 10;
          double width = constraints.maxWidth / 10 * 8;
          if (largeScreen) {
            sidePadding = constraints.maxWidth / 5;
            width = constraints.maxWidth / 10 * 6;
            tamanhoTexto = (constraints.maxHeight /
                20); //Cambiar esto para que quepan todos los títulos en web.
          }
          var children = <Widget>[
            SizedBox(
              height: tamanhoTexto * 2,
            ),
            Row(mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[
              Padding(
                padding: EdgeInsets.only(
                    left: constraints.maxWidth / 10,
                    right: constraints.maxWidth / 10),
                child: Container(
                  width: constraints.maxWidth / 10 * 8,
                  child: Center(
                      child: Text('Performance',
                          style: TextStyle(fontSize: tamanhoTexto * 1.5))),
                ),
              ),
              SizedBox(
                height: tamanhoTexto * 2,
              ),
            ]),
          ];
          //Aqui se agrega todo el contenido.
          children.add(
            Row(mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[
              Padding(
                padding: EdgeInsets.only(left: sidePadding, right: sidePadding),
                child: Container(
                    width: width,
                    child: RichText(
                      softWrap: true,
                      textAlign: TextAlign.justify,
                      text: new TextSpan(
                        children: [
                          new TextSpan(
                            text: 'Primeramente, debido a que el objetivo de este proyecto es entender mejor la transformación que ocurre de flutter(Dart) a web(Html,Javascript),' +
                                ' se decidió analizar las diferencias entre una aplicación móvil y una pagina web. Para esto, dado que los productos' +
                                ' finales son tan diferentes y que no existe una sola herramienta que logre perfilar correctamente el performance de las dos aplicaciones,' +
                                ' se decidió analizar cada una con su herramienta mas apropiada y juntar este análisis con una mas generalizada.\n\nCon un buen escenario de prueba en mente, y dado que las' +
                                ' herramientas no pueden gravar al mismo tiempo sin alterar las mediciones, se establecieron los siguientes pasos de prueba:\n1. Abrir la aplicación(cuando la herramienta lo permite).\n' +
                                '2. Esperar a que cargue la pagina principal\n3. Abrir la primera sección la cual se denomina "Flutter".\n4. Scrollear la pantalla completamente hacia abajo.\n5. Hacerle 5 "Ups" a la sección.\n6. ' +
                                'Esperar 3 segundos para estar seguros que se manda la petición al servidor\n7. Deshabilitar la conexión al wifi(Cuando la herramienta lo permite)\n8. Hacer un "Refresh" de la seccion.\n9. Salir de la sección ' +
                                'y entrar a la de RoadBLOCks.\n10. Scrollear completamente hacia abajo.\n11. Salirse de la sección.\n\nEstos pasos se pueden ver reflejados en las capturas a seguir:',
                            style: TextStyle(
                                fontSize: tamanhoTexto * 0.75,
                                color: Colors.black),
                          ),
                        ],
                      ),
                    )),
              ),
            ]),
          );
          children.add(
            Row(mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[
              Padding(
                padding: EdgeInsets.only(left: sidePadding, right: sidePadding),
                child: Container(
                    width: width,
                    child: Image(image: AssetImage('images/movil.gif'))),
              ),
            ]),
          );
          children.add(SizedBox(
            height: tamanhoTexto / 2,
          ));
          children.add(
            Row(mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[
              Padding(
                padding: EdgeInsets.only(left: sidePadding, right: sidePadding),
                child: Container(
                    width: width,
                    child: Image(image: AssetImage('images/web.gif'))),
              ),
            ]),
          );
          children.add(SizedBox(
            height: tamanhoTexto / 2,
          ));
          children.add(
            Row(mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[
              Padding(
                padding: EdgeInsets.only(left: sidePadding, right: sidePadding),
                child: Container(
                    width: width,
                    child: RichText(
                      softWrap: true,
                      textAlign: TextAlign.justify,
                      text: new TextSpan(
                        children: [
                          new TextSpan(
                            text: 'Se debe notar que se decidió probar estos pasos ya que estos abarcan prácticamente todos las funcionalidades de la aplicación, ya que a pesar de que se cambie la sección, ' +
                                'el código seguirá siendo el mismo. Además de esto, el hecho de cargar la segunda sección sin acceso a internet nos permitió entender mejor como funciona la versión web. ',
                            style: TextStyle(
                                fontSize: tamanhoTexto * 0.75,
                                color: Colors.black),
                          ),
                        ],
                      ),
                    )),
              ),
            ]),
          );
          children.add(SizedBox(
            height: tamanhoTexto / 2,
          ));
          children.add(
            Row(mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[
              Padding(
                padding: EdgeInsets.only(left: sidePadding, right: sidePadding),
                child: Container(
                    width: width,
                    child: RichText(
                      softWrap: true,
                      textAlign: TextAlign.center,
                      text: new TextSpan(
                        children: [
                          new TextSpan(
                            text: 'Nativa',
                            style: TextStyle(
                                fontSize: tamanhoTexto * 0.75,
                                fontWeight: FontWeight.bold,
                                color: Colors.black),
                          ),
                        ],
                      ),
                    )),
              ),
            ]),
          );
          children.add(
            Row(mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[
              Padding(
                padding: EdgeInsets.only(left: sidePadding, right: sidePadding),
                child: Container(
                    width: width,
                    child: RichText(
                      softWrap: true,
                      textAlign: TextAlign.justify,
                      text: new TextSpan(
                        children: [
                          new TextSpan(
                            text: 'Con respecto al análisis realizado en la versión nativa de la aplicación,' +
                                ' se decidió hacerse sobre los developer tools de dart. En la imagen siguiente se encuentra el perfilamiento de CPU obtenido al replicar los pasos establecidos.',
                            style: TextStyle(
                                fontSize: tamanhoTexto * 0.75,
                                color: Colors.black),
                          ),
                        ],
                      ),
                    )),
              ),
            ]),
          );
          children.add(SizedBox(
            height: tamanhoTexto / 2,
          ));
          children.add(
            Row(mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[
              Padding(
                padding: EdgeInsets.only(left: sidePadding, right: sidePadding),
                child: Container(
                    width: width,
                    child: Image(image: AssetImage('images/cpumovil.jpg'))),
              ),
            ]),
          );
          children.add(SizedBox(
            height: tamanhoTexto / 2,
          ));
          children.add(
            Row(mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[
              Padding(
                padding: EdgeInsets.only(left: sidePadding, right: sidePadding),
                child: Container(
                    width: width,
                    child: RichText(
                      softWrap: true,
                      textAlign: TextAlign.justify,
                      text: new TextSpan(
                        children: [
                          new TextSpan(
                            text: 'Como se puede notar, en la imagen se encuentra enumerada con los respectivos pasos denotados anteriormente y el momento en que ocurrieron.Primero, se puede ver como carga toda la pagina, lo que se genera el grande bloque de procesamiento.' +
                                'Luego, en el paso 3 se puede ver como se actualiza la interfaz rápidamente al scrollear la aplicación. Y en el paso 5 se muestra el procesamiento necesario para actualizar el contador y la animación de click del action button al hacer los 5 ups consecutivos.' +
                                'Finalmente, se nota la espera, el click del refrescar la pagina y la apertura de la nueva sección con su respectivo scroll. Es importante detallar que el procesamiento de renderización se hace en su gran mayoria al inicio de la aplicación de tal forma que la animación de la apertura de una seccion es "smooth"' +
                                'En la imagen a seguir se encuentra el perfilamiento del uso de la memoria de la aplicación.',
                            style: TextStyle(
                                fontSize: tamanhoTexto * 0.75,
                                color: Colors.black),
                          ),
                        ],
                      ),
                    )),
              ),
            ]),
          );
          children.add(SizedBox(
            height: tamanhoTexto / 2,
          ));
          children.add(
            Row(mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[
              Padding(
                padding: EdgeInsets.only(left: sidePadding, right: sidePadding),
                child: Container(
                    width: width,
                    child:
                        Image(image: AssetImage('images/movilmemoria.jpeg'))),
              ),
            ]),
          );
          children.add(SizedBox(
            height: tamanhoTexto / 2,
          ));
          children.add(
            Row(mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[
              Padding(
                padding: EdgeInsets.only(left: sidePadding, right: sidePadding),
                child: Container(
                    width: width,
                    child: RichText(
                      softWrap: true,
                      textAlign: TextAlign.justify,
                      text: new TextSpan(
                        children: [
                          new TextSpan(
                            text: 'Nuevamente, esta se encuentra enumerada con los pasos que se pueden observar, en general se debe tener en cuenta que como la aplicación es principalmente estática no hay un cambio importante en la memoria de la aplicación.' +
                                ' Además, la grande ocupación de memoria (70mb) se debe principalmente a las imágenes, Finalmente, los picos seguidos por el gc se deben a los momentos en que shared_preferences accede ' +
                                'a la memoria, verifica las variables y las deja de utilizar.',
                            style: TextStyle(
                                fontSize: tamanhoTexto * 0.75,
                                color: Colors.black),
                          ),
                        ],
                      ),
                    )),
              ),
            ]),
          );
          children.add(SizedBox(
            height: tamanhoTexto / 2,
          ));
          children.add(
            Row(mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[
              Padding(
                padding: EdgeInsets.only(left: sidePadding, right: sidePadding),
                child: Container(
                    width: width,
                    child: RichText(
                      softWrap: true,
                      textAlign: TextAlign.center,
                      text: new TextSpan(
                        children: [
                          new TextSpan(
                            text: 'Web',
                            style: TextStyle(
                                fontSize: tamanhoTexto * 0.75,
                                fontWeight: FontWeight.bold,
                                color: Colors.black),
                          ),
                        ],
                      ),
                    )),
              ),
            ]),
          );
          children.add(
            Row(mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[
              Padding(
                padding: EdgeInsets.only(left: sidePadding, right: sidePadding),
                child: Container(
                    width: width,
                    child: RichText(
                      softWrap: true,
                      textAlign: TextAlign.justify,
                      text: new TextSpan(
                        children: [
                          new TextSpan(
                            text: 'Con respecto al análisis realizado en la versión web de la aplicación,' +
                                ' se decidió hacerse sobre los chrome dev tools, ya que estos están especializados en el análisis de código Javascript. En la imagen a seguir se encuentra el perfilamiento del CPU obtenido al replicar los pasos establecidos.',
                            style: TextStyle(
                                fontSize: tamanhoTexto * 0.75,
                                color: Colors.black),
                          ),
                        ],
                      ),
                    )),
              ),
            ]),
          );
          children.add(SizedBox(
            height: tamanhoTexto / 2,
          ));
          children.add(
            Row(mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[
              Padding(
                padding: EdgeInsets.only(left: sidePadding, right: sidePadding),
                child: Container(
                    width: width,
                    child: Image(image: AssetImage('images/cpuweb.jpeg'))),
              ),
            ]),
          );
          children.add(SizedBox(
            height: tamanhoTexto / 2,
          ));
          children.add(
            Row(mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[
              Padding(
                padding: EdgeInsets.only(left: sidePadding, right: sidePadding),
                child: Container(
                    width: width,
                    child: RichText(
                      softWrap: true,
                      textAlign: TextAlign.justify,
                      text: new TextSpan(
                        children: [
                          new TextSpan(
                            text: 'Como se puede notar, en la imagen se encuentra enumerada con los respectivos pasos denotados anteriormente y el momento en que ocurrieron.Primero, se puede ver como carga toda la pagina, lo que se genera el primer bloque de procesamiento de la primera vista' +
                                'Luego, en el paso 3 se puede ver como se actualiza la interfaz rápidamente al scrollear la aplicación. Y en el paso 5 se muestra el procesamiento necesario para actualizar el contador y la animación de click del action button al hacer los 5 ups consecutivos.' +
                                'Finalmente, se puede ver como la apertura de la nueva sección con su respectivo scroll consumen una grande cantidad de procesamiento. Es importante detallar que el procesamiento de renderización se hace en el momento que se genera la acción. Este gran consumo de CPU al scrollear se debe a que aún no esta bien optimizado. Según algunos participantes en los foros de desarrollo de flutter,' +
                                'Como en las aplicaciones nativas es importante renderizar únicamente lo que se muestra en pantalla, mientras que en html se encarga el browser, el código generado por dart2js también intenta hacer lo mismo haciendo que cada vez que se tenga que volver a renderizar o pintar alguno componente de la aplicación se vuelva a procesar una gran cantidad de información.' +
                                ' Además, el pico demarcado por un * indica el momento donde se cargaron los gifs de la sección de RoadBLOCks tal que, como se podrá ver mejor en el análisis de memoria, estos se descargan únicamente en el momento que aparecen en la pantalla.\n\nAntes de analizar el perfilamiento de memoria cabe resaltar que para replicar correctamente la descarga de los componentes necesarios se borró el cache de google chrome y se realizo todo el proceso en un tab incognito. ',
                            style: TextStyle(
                                fontSize: tamanhoTexto * 0.75,
                                color: Colors.black),
                          ),
                        ],
                      ),
                    )),
              ),
            ]),
          );
          children.add(SizedBox(
            height: tamanhoTexto / 2,
          ));

          children.add(SizedBox(
            height: tamanhoTexto / 2,
          ));
          children.add(
            Row(mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[
              Padding(
                padding: EdgeInsets.only(left: sidePadding, right: sidePadding),
                child: Container(
                    width: width,
                    child: Image(image: AssetImage('images/webmemoria.jpeg'))),
              ),
            ]),
          );
          children.add(SizedBox(
            height: tamanhoTexto / 2,
          ));
          children.add(
            Row(mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[
              Padding(
                padding: EdgeInsets.only(left: sidePadding, right: sidePadding),
                child: Container(
                    width: width,
                    child: RichText(
                      softWrap: true,
                      textAlign: TextAlign.justify,
                      text: new TextSpan(
                        children: [
                          new TextSpan(
                            text: 'Dado el tamaño de los picos en memoria que se pueden observar en la imagen anterior, no se enumeraron los pasos. A pesar de esto, se pueden distinguir los pasos que renderizaron pantallas con azul. De esto lo que principalmente se ' +
                                'debe resaltar es la enormidad del archivo que se cargó al abrir la pagina, este siendo de mas de 1mb. Con respecto a esto, en retrospectiva del desarrollo en web, el archivo generado por el tutorial más básico posible fue de 1Mb, mientras que el de la versión final fue de 1.2Mb' +
                                'Esto puede estar causado por la buena minimización de los archivos por parte de dart2js, lo que al mismo tiempo implica que no logró minimizar aun más las librerías nativas de flutter. También se puede recalcar que como la información se carga en el momento de renderización este pico inicial no corresponde a las imágenes de la aplicación.' +
                                'Finalmente, como se puede observar en la imagen a seguir, en general lo que mas ocupó memoria fueron los archivos de código y su contenido textual.',
                            style: TextStyle(
                                fontSize: tamanhoTexto * 0.75,
                                color: Colors.black),
                          ),
                        ],
                      ),
                    )),
              ),
            ]),
          );
          children.add(SizedBox(
            height: tamanhoTexto / 2,
          ));
          children.add(
            Row(mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[
              Padding(
                padding: EdgeInsets.only(left: sidePadding, right: sidePadding),
                child: Container(
                    width: width,
                    child: Image(image: AssetImage('images/totalmemweb.jpeg'))),
              ),
            ]),
          );
          children.add(SizedBox(
            height: tamanhoTexto / 2,
          ));
          children.add(
            Row(mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[
              Padding(
                padding: EdgeInsets.only(left: sidePadding, right: sidePadding),
                child: Container(
                    width: width,
                    child: RichText(
                      softWrap: true,
                      textAlign: TextAlign.justify,
                      text: new TextSpan(
                        children: [
                          new TextSpan(
                            text: 'Por otro lado en la imagen a seguir se puede observar la utilización del cache de la pagina web, tal que la variable ups representa los "Ups" temporarios que faltan por actualizar a la base de datos.' +
                                ' Dado que este proceso se hizo con acceso a internet este valor es 0.' +
                                'Además, como no se realizó ningún "Up" en la sección de RoadBLOCks esta variable no existe en el cache del dispositivo.',
                            style: TextStyle(
                                fontSize: tamanhoTexto * 0.75,
                                color: Colors.black),
                          ),
                        ],
                      ),
                    )),
              ),
            ]),
          );
          children.add(SizedBox(
            height: tamanhoTexto / 2,
          ));
          children.add(
            Row(mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[
              Padding(
                padding: EdgeInsets.only(left: sidePadding, right: sidePadding),
                child: Container(
                    width: width,
                    child: Image(image: AssetImage('images/cacheweb.jpeg'))),
              ),
            ]),
          );
          children.add(SizedBox(
            height: tamanhoTexto / 2,
          ));
          children.add(
            Row(mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[
              Padding(
                padding: EdgeInsets.only(left: sidePadding, right: sidePadding),
                child: Container(
                    width: width,
                    child: RichText(
                      softWrap: true,
                      textAlign: TextAlign.center,
                      text: new TextSpan(
                        children: [
                          new TextSpan(
                            text: 'General',
                            style: TextStyle(
                                fontSize: tamanhoTexto * 0.75,
                                fontWeight: FontWeight.bold,
                                color: Colors.black),
                          ),
                        ],
                      ),
                    )),
              ),
            ]),
          );
          children.add(
            Row(mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[
              Padding(
                padding: EdgeInsets.only(left: sidePadding, right: sidePadding),
                child: Container(
                    width: width,
                    child: RichText(
                      softWrap: true,
                      textAlign: TextAlign.justify,
                      text: new TextSpan(
                        children: [
                          new TextSpan(
                            text: 'Como las herramientas utilizadas para el perfilamiento de las aplicaciones fueron diferentes se decidió realizar un perfilamiento más con la herramienta de systrace con la cual obtuvimos los siguientes reportes de móvil y web respectivamente. ' +
                                'Estos reportes confirman lo que se estableció anteriormente ya que en general la aplicación móvil solo tuvo un aumento en la utilización de los recursos al inicio y en el momento de aumentar los "Ups", mientras que la aplicación web tuvo una utilización más constante ya que esta gasta mas recursos al renderizar la aplicación.' +
                                '',
                            style: TextStyle(
                                fontSize: tamanhoTexto * 0.75,
                                color: Colors.black),
                          ),
                        ],
                      ),
                    )),
              ),
            ]),
          );
          children.add(SizedBox(
            height: tamanhoTexto / 2,
          ));
          children.add(
            Row(mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[
              Padding(
                padding: EdgeInsets.only(left: sidePadding, right: sidePadding),
                child: Container(
                    width: width,
                    child: Image(image: AssetImage('images/perfmov.jpeg'))),
              ),
            ]),
          );
          children.add(SizedBox(
            height: tamanhoTexto / 2,
          ));
          children.add(
            Row(mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[
              Padding(
                padding: EdgeInsets.only(left: sidePadding, right: sidePadding),
                child: Container(
                    width: width,
                    child: Image(image: AssetImage('images/perfweb.jpeg'))),
              ),
            ]),
          );
          children.add(SizedBox(
            height: tamanhoTexto / 2,
          ));
          return (ListView(children: children));
        }),
        floatingActionButton: FloatingActionButton(
          onPressed: () {
            add();
          },
          tooltip: 'Increment',
          child: Icon(Icons.arrow_upward),
        ));
  }

  @override
  void initState() {
    super.initState();
    //Se carga el cache
    contador = InfoTema(index: index, contador: 0, contadorTemp: 0);
    try {
      String storedCounter = html.window.localStorage[id];
      if (storedCounter != null) {
        contador.contador = int.parse(storedCounter);
      }
    } catch (error) {
      print("Error cargando cache: $error");
    }
    //Contador Sin Enviar
    try {
      String storedCounter = html.window.localStorage[id + "-UPS"];
      if (storedCounter != null) {
        contador.contadorTemp = int.parse(storedCounter);
      }
    } catch (error) {
      print("Error cargando cache: $error");
    }
    try {
      setState(() {
        con = contador.contador + contador.contadorTemp;
      });
    } catch (error) {}
  }

  add() async {
    contador.contadorTemp++;
    if (hasConnection()) {
      await updateTemp();
      doUp(id);
    } else {
      //Guardar en cache.
      estabaOff = true;
      guardarContTemp();
    }
    try {
      setState(() {
        con = contador.contador + contador.contadorTemp;
      });
    } catch (error) {}
  }

  refresh() async {
    if (hasConnection()) {
      await updateTemp();
      var resp = await update(contador.index.toString());
      if (resp.body.toString().contains("ups")) {
        var temp = json.decode(resp.body.toString());
        contador.contador = temp["ups"];
        guardarCont();
        try {
          setState(() {
            con = contador.contador + contador.contadorTemp;
          });
        } catch (error) {}
      }
    } else {
      estabaOff = true;
      _scaffoldKey.currentState.showSnackBar(SnackBar(
        content: Text("No hay conexión a Internet"),
        action: SnackBarAction(
          label: 'Reintentar',
          onPressed: () {
            refresh();
          },
        ),
        backgroundColor: Colors.red,
        duration: Duration(seconds: 5),
      ));
    }
  }

  load() async {
    if (hasConnection()) {
      await updateTemp();
      var resp = await update(contador.index.toString());
      if (resp.body.toString().contains("ups")) {
        var temp = json.decode(resp.body.toString());
        contador.contador = temp["ups"];
        guardarCont();
        try {
          setState(() {
            con = contador.contador + contador.contadorTemp;
          });
        } catch (error) {}
      }
    } else {}
  }

  updateTemp() async {
    if (estabaOff) {
      if (contador.contadorTemp > 0) {
        var resp = await upVote(contador);
        if (resp != null && resp.body.toString().contains("ups")) {
          var temp = json.decode(resp.body.toString());
          contador.contadorTemp = 0;
          contador.contador = temp["ups"];
          guardarCont();
          guardarContTemp();
          try {
            setState(() {
              con = contador.contador + contador.contadorTemp;
            });
          } catch (error) {}
        }
      }
      estabaOff = false;
    }
  }

  doUp(id) async {
    try {
      if (contador.timer != null) {
        contador.timer.cancel();
      }
      contador.timer = new Timer(new Duration(seconds: 3), () async {
        var resp = await upVote(contador);
        if (resp != null && resp.body.toString().contains("ups")) {
          var temp = json.decode(resp.body.toString());
          contador.contadorTemp = 0;
          contador.contador = temp["ups"];
          guardarCont();
          guardarContTemp();
          try {
            setState(() {
              con = contador.contador + contador.contadorTemp;
            });
          } catch (error) {}
        }
      });
    } catch (e) {
      print(e);
    }
  }

  guardarCont() async {
    try {
      html.window.localStorage[id] = contador.contador.toString();
    } catch (error) {
      print("Error guardando en cache: $error");
    }
  }

  guardarContTemp() async {
    try {
      html.window.localStorage[id + "-UPS"] = contador.contadorTemp.toString();
    } catch (error) {
      print("Error guardando en cache: $error");
    }
  }
}
